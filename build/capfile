require 'json'
require 'net/ftp'

require 'capistrano_colors'

# Capistrano recipe for building and testing Micro Cloud Foundry from Jenkins.

# Pass these command line arguments to capistrano to set variables.
#
# -s vmrun= \
# -s vm_initial_password= \
# -s micro_password= \
# -s domain= \
# -s admin_user= \
# -s admin_password= \
# -s normal_user= \
# -s normal_password= \
# -s http_proxy= \
# -s cdn_ftp_host= \
# -s cdn_ftp_user= \
# -s cdn_ftp_password=

# ENV['BUILD_SERVER'] and ENV['TEST_SERVER'] must also be set.

load 'deploy'

role :build, ENV['BUILD_SERVER']
role :test, ENV['TEST_SERVER']

set :user, 'mmb'

ssh_options[:keys] = '/var/lib/jenkins/.ssh/id_rsa'

# Track MCF versions that have been uploaded to the CDN.
class VersionStore

  def initialize(path)
    @path = path
    @releases = []
    @nightlies = []

    read  if File.exist?(path)
  end

  # Read the store from disk.
  def read
    open(path) do |f|
      data = JSON.parse(f.read)

      @releases = data.fetch('release', [])
      @nightlies = data.fetch('nightly', [])
    end
  end

  # Write the contents of the store to disk in JSON.
  def write
    open(path, 'w') do |f|
      f.flock(File::LOCK_EX)
      f.write to_json
      f.flock(File::LOCK_UN)
    end
  end

  # Return true if the store contains a release tag.
  def has_release?(tag)
    @releases.index { |r| r[/^micro-#{tag}-/] }
  end

  def to_h
    {
      'release' => @releases.uniq,
      'nightly' => @nightlies.uniq
    }
  end

  def to_json
    to_h.to_json
  end

  def pretty
    JSON.pretty_generate(to_h)
  end

  attr_accessor :path
  attr_accessor :releases
  attr_accessor :nightlies
end

# Send data to virtual console 1 on a VM as if it had been typed there.
def vm_console_send(vmx_path, data, password, options={})
  options = {
    :vmrun => 'vmrun',
    :user => 'root',
    :remote_ruby => '/var/vcap/bosh/bin/ruby',
    }.merge(options)

  header = <<-eos
open('/dev/tty1', 'w') do |o|
  DATA.each_char do |c|
    o.ioctl(0x5412, c)
    sleep(rand(100) / 300.0)
  end
end
__END__
eos

  local_script = '/tmp/script.rb'
  remote_script = '/tmp/script.rb'

  open(local_script, 'w') { |f| f << header << data }

  run_locally "#{options[:vmrun]} -gu #{options[:user]} -gp #{password} CopyFileFromHostToGuest \"#{vmx_path}\" #{local_script} #{remote_script}"

  run_locally "#{options[:vmrun]} -gu #{options[:user]} -gp #{password} runProgramInGuest \"#{vmx_path}\" #{options[:remote_ruby]} #{remote_script}"
end

def vm_ip(vmx_path, password, options={})
  options = {
    :vmrun => 'vmrun',
    :user => 'root',
    :interface => 'eth0',
    }.merge(options)

  run_locally "#{options[:vmrun]} -gu #{options[:user]} -gp #{password} runScriptInGuest \"#{vmx_path}\" /bin/sh \"/sbin/ifconfig #{options[:interface]} > /tmp/ifconfig\""

  run_locally "#{options[:vmrun]} -gu #{options[:user]} -gp #{password} CopyFileFromGuestToHost \"#{vmx_path}\" /tmp/ifconfig /tmp/ifconfig"

  `cat /tmp/ifconfig`[/inet addr:(\S+) /,1]
end

def run_commands(commands)
  run commands.join(' && ')
end

desc 'Clean up build debris.'
task :clean, :roles => :build do
  # TODO add /tmp
  run_commands([
    "#{sudo} rm -rf /var/tmp/bosh/agent-*",
    'rm -rf ~/cf-release/dev_releases/*',
    "#{sudo} rm -rf ~/bosh/agent/mcf/*",
  ])
end

desc 'Get the latest cf-release tag.'
task :latest_cf_release_tag, :roles => :build do
  run 'git --git-dir ~/cf-release/.git fetch'

  output = capture('git --git-dir ~/cf-release/.git show-ref --tags')

  tags = []

  output.lines do |line|
    match = %r{refs/tags/v(\d+)$}.match(line)
    if match
      tags << match[1].to_i
    end
  end

  "v#{tags.sort.last}"
end

desc 'Create Micro Cloud Foundry bosh release.'
task :create_release, :roles => :build do
  run_commands([
    '. ~/.bash_profile',
    'cd ~/cf-release',
    'bosh create release --force --with-tarball',
  ])
end

desc 'Update micro.'
task :update_micro, :roles => :build do
  run_commands([
    'cd ~/micro',
    'git pull',
  ])
end

desc 'Update bosh agent.'
task :update_bosh_agent, :roles => :build do
  run_commands([
    '. ~/.bash_profile',
    'cd ~/bosh/agent',
    'git pull',
    'bundle update',
  ])
end

desc 'Describe the latest commit in cf-release on the build machine.'
task :desc_cf_release, :roles => :build do
  output = capture('git --git-dir ~/cf-release/.git describe --tags').chomp
  output.gsub! /-(\d+)-[\da-z]+$/, 'p\\1'
  output
end

desc 'Checkout the latest cf-release master on the build machine.'
task :checkout_cf_release_master, :roles => :build do
  run_commands([
    'cd ~/cf-release',
    'git checkout master',
    './update'
  ])
end

desc 'Checkout a cf-release tag on the build machine.'
task :checkout_cf_release_tag, :roles => :build do
  run_commands([
    'cd ~/cf-release',
    'git fetch',
    "git checkout -b #{tag}branch #{tag}",
    'git submodule update --init --recursive'
  ])
end

desc 'Run vcap-yeti tests.'
task :bvt, :roles => :test do
  # Set the nameserver of the test machine to the Micro Cloud VM.
  resolv_conf_backup = '~/resolv.conf.backup'

  run "cp /etc/resolv.conf #{resolv_conf_backup}"
  run "echo 'nameserver #{micro_vm_ip}' > /tmp/resolv.conf"
  run "#{sudo} cp /tmp/resolv.conf /etc/resolv.conf"

  run_commands([
    '. ~/.bash_profile',
    "vmc --trace target http://api.#{domain}/",
    "vmc --trace register '#{admin_user}' --password '#{admin_password}' --verify '#{admin_password}'",
    "vmc --trace register #{normal_user} --password '#{normal_password}' --verify '#{normal_password}'",
    "export VCAP_BVT_TARGET=#{domain}",
    "export VCAP_BVT_ADMIN_USER='#{admin_user}'",
    "export VCAP_BVT_ADMIN_USER_PASSWD='#{admin_password}'",
    "export VCAP_BVT_USER='#{normal_user}'",
    "export VCAP_BVT_USER_PASSWD='#{normal_password}'",
    'cd ~/vcap-yeti',
    'env',
    './update.sh',
    'rm -rf ~/.bvt',
    'bundle exec rake full[1]'
    ])

    run "#{sudo} cp #{resolv_conf_backup} /etc/resolv.conf"
end

desc 'Distribute a nightly version of the Micro Cloud.'
task :dist_nightly do
  p "sending #{zip_local_path} to CDN #{cdn_ftp_host}/micro/nightly"

  Net::FTP.open(cdn_ftp_host, cdn_ftp_user, cdn_ftp_password) do |ftp|
    ftp.putbinaryfile(zip_local_path, "micro/nightly/#{zip_name}")
  end

  p "http://download3.vmware.com/cloudfoundry/micro/nightly/#{zip_name}"
end

desc 'Distribute a release version of the Micro Cloud.'
task :dist_release do
  p "sending #{zip_local_path} to CDN #{cdn_ftp_host}/micro/release"

  Net::FTP.open(cdn_ftp_host, cdn_ftp_user, cdn_ftp_password) do |ftp|
    ftp.putbinaryfile(zip_local_path, "micro/release/#{zip_name}")
  end

  p "http://download3.vmware.com/cloudfoundry/micro/release/#{zip_name}"
end

desc 'Build and test the latest Micro Cloud Foundry.'
task :build, :roles => :build do
  clean

  set :tag, latest_cf_release_tag

  version_store = VersionStore.new('/var/lib/jenkins/versions.json')

  if version_store.has_release?(tag)
    checkout_cf_release_master
    release_desc = "#{tag}+"
    is_release_version = false
  else
    checkout_cf_release_tag
    release_desc = tag
    is_release_version = true
  end

  create_release
  update_bosh_agent
  update_micro

  set :build_time, Time.now.strftime('%Y%m%d.%H%M%S')
  set :version, "#{release_desc}-#{build_time}"

  run_commands([
    '. ~/.bash_profile',
    "export BUILD_TIME=#{build_time}",
    "export MCF_VERSION=#{version}",
    'export UBUNTU_ISO=~/ubuntu-10.04.4-server-amd64.iso',
    'export UBUNTU_MIRROR=http://localhost:9999/ubuntu',
    'LATEST_RELEASE=`ls -t ~/cf-release/dev_releases/micro-*-dev.tgz | head -1`',
    'cd ~/bosh/agent',
    'rake stemcell2:mcf[vsphere,~/cf-release/micro/manifest.yml,$LATEST_RELEASE]'
    ])

  build_host = find_servers_for_task(current_task)[0]

  set :zip_name, "micro-#{version}.zip"

  set :zip_local_path, "/tmp/#{zip_name}"

  zip_path = "mmb@#{build_host}:bosh/agent/mcf/#{build_time}/#{zip_name}"

  run_locally "scp #{zip_path} /tmp"

  puts run_locally "cd /tmp && unzip -o #{zip_name}"

  vmx = '/tmp/micro/micro.vmx'

  run_locally "#{vmrun} start #{vmx} nogui"

  sleep 30

  config_commands = <<-eos
1
#{micro_password}
#{micro_password}
1
#{http_proxy}
#{domain}
#{admin_user}
quit
y
eos

  vm_console_send vmx, config_commands, vm_initial_password

  # Give MCF time to boot.

  sleep 300

  # Turn on online mode.
  vm_console_send vmx, "\n6\n", micro_password

  set :micro_vm_ip, vm_ip(vmx, micro_password)

  p micro_vm_ip

  bvt

  if is_release_version
    dist_release
    version_store.releases.insert(0, zip_name)
  else
    dist_nigthly
    version_store.nightlies.insert(0, zip_name)
  end

  version_store.write

  p "sending #{version_store.path} to CDN #{cdn_ftp_host}/micro/versions.json"
  p version_store.pretty
  Net::FTP.open(cdn_ftp_host, cdn_ftp_user, cdn_ftp_password) do |ftp|
    ftp.putbinaryfile(version_store.path, "micro/versions.json")
  end

  # Archive build?

  # Cleanup.

  # run_locally "#{vmrun} stop #{vmx} nogui"
  # rm -rf /tmp/micro
end
