require 'json'
require 'net/ftp'

require 'capistrano_colors'

# Capistrano recipe for building and testing Micro Cloud Foundry from Jenkins.

# Pass these command line arguments to capistrano to set variables.
#
# -s vmrun= \
# -s vm_initial_password= \
# -s micro_password= \
# -s domain= \
# -s admin_user= \
# -s admin_password= \
# -s normal_user= \
# -s normal_password= \
# -s http_proxy= \
# -s cdn_ftp_host= \
# -s cdn_ftp_user= \
# -s cdn_ftp_password=

# ENV['BUILD_SERVER'] and ENV['TEST_SERVER'] must also be set.

load 'deploy'

role :build, ENV['BUILD_SERVER']
role :test, ENV['TEST_SERVER']

set :user, 'mmb'

ssh_options[:keys] = '/var/lib/jenkins/.ssh/id_rsa'

# Track MCF versions that have been uploaded to the CDN.
class VersionStore

  def initialize(path)
    @path = path
    @releases = []
    @nightlies = []
    @default = nil

    read  if File.exist?(path)
  end

  # Read the store from disk.
  def read
    open(path) do |f|
      data = JSON.parse(f.read)

      @releases = data.fetch('release', [])
      @nightlies = data.fetch('nightly', [])
      @default = data.fetch('default', nil)
    end
  end

  # Write the contents of the store to disk in JSON.
  def write
    open(path, 'w') do |f|
      f.flock(File::LOCK_EX)
      f.write to_json
      f.flock(File::LOCK_UN)
    end
  end

  # Return true if the store contains a release tag.
  def has_release?(tag)
    @releases.index { |r| r[/^micro-#{tag}-/] }
  end

  def to_h
    {
      'release' => @releases.uniq,
      'nightly' => @nightlies.uniq,
      'default' => default
    }
  end

  def to_json
    to_h.to_json
  end

  def pretty
    JSON.pretty_generate(to_h)
  end

  def default
    @default || releases[0]
  end

  attr_accessor :path
  attr_accessor :releases
  attr_accessor :nightlies
  attr_writer :default
end

# Send data to virtual console 1 on a VM as if it had been typed there.
def vm_console_send(vmx_path, data, password, options={})
  options = {
    :vmrun => 'vmrun',
    :user => 'root',
    :remote_ruby => '/var/vcap/bosh/bin/ruby',
    }.merge(options)

  header = <<-eos
open('/dev/tty1', 'w') do |o|
  DATA.each_char do |c|
    o.ioctl(0x5412, c)
    sleep(rand(100) / 300.0)
  end
end
__END__
eos

  local_script = '/tmp/script.rb'
  remote_script = '/tmp/script.rb'

  open(local_script, 'w') { |f| f << header << data }

  run_locally "#{options[:vmrun]} -gu #{options[:user]} -gp #{password} CopyFileFromHostToGuest \"#{vmx_path}\" #{local_script} #{remote_script}"

  run_locally "#{options[:vmrun]} -gu #{options[:user]} -gp #{password} runProgramInGuest \"#{vmx_path}\" #{options[:remote_ruby]} #{remote_script}"
end

def vm_ip(vmx_path, password, options={})
  options = {
    :vmrun => 'vmrun',
    :user => 'root',
    :interface => 'eth0',
    }.merge(options)

  run_locally "#{options[:vmrun]} -gu #{options[:user]} -gp #{password} runScriptInGuest \"#{vmx_path}\" /bin/sh \"/sbin/ifconfig #{options[:interface]} > /tmp/ifconfig\""

  run_locally "#{options[:vmrun]} -gu #{options[:user]} -gp #{password} CopyFileFromGuestToHost \"#{vmx_path}\" /tmp/ifconfig /tmp/ifconfig"

  `cat /tmp/ifconfig`[/inet addr:(\S+) /,1]
end

def run_commands(commands)
  run commands.join(' && ')
end

def is_release_version(filename)
  filename[/^micro-v\d+-/]
end

desc 'Clean up build debris.'
task :clean, :roles => :build do
  # TODO add /tmp
  run_commands([
    "#{sudo} rm -rf /var/tmp/bosh/agent-*",
    'rm -rf ~/cf-release/dev_releases/*',
    "#{sudo} rm -rf ~/bosh/agent/mcf/*",
  ])
end

desc 'Get the latest cf-release tag.'
task :latest_cf_release_tag, :roles => :build do
  run 'git --git-dir ~/cf-release/.git fetch'

  output = capture('git --git-dir ~/cf-release/.git show-ref --tags')

  tags = []

  output.lines do |line|
    match = %r{refs/tags/v(\d+)$}.match(line)
    if match
      tags << match[1].to_i
    end
  end

  "v#{tags.sort.last}"
end

desc 'Create Micro Cloud Foundry bosh release.'
task :create_release, :roles => :build do
  run_commands([
    '. ~/.bash_profile',
    'cd ~/cf-release',
    'bosh create release --force --with-tarball',
  ])
end

desc 'Update micro.'
task :update_micro, :roles => :build do
  run_commands([
    'cd ~/micro',
    'git pull',
  ])
end

desc 'Update bosh agent.'
task :update_bosh_agent, :roles => :build do
  run_commands([
    '. ~/.bash_profile',
    'cd ~/bosh/agent',
    'git pull',
    'bundle update',
  ])
end

desc 'Describe the latest commit in cf-release on the build machine.'
task :desc_cf_release, :roles => :build do
  output = capture('git --git-dir ~/cf-release/.git describe --tags').chomp
  output.gsub! /-(\d+)-[\da-z]+$/, 'p\\1'
  output
end

desc 'Checkout the latest cf-release master on the build machine.'
task :checkout_cf_release_master, :roles => :build do
  run_commands([
    'cd ~/cf-release',
    'git checkout master',
    './update'
  ])
end

desc 'Checkout a cf-release tag on the build machine.'
task :checkout_cf_release_tag, :roles => :build do
  run_commands([
    'cd ~/cf-release',
    'git checkout master',
    'git pull',
    "git branch -f #{tag}branch #{tag}",
    "git checkout #{tag}branch",
    'git submodule update --init --recursive'
  ])
end

desc 'Checkout the latest cf-release master on the test machine.'
task :checkout_cf_release_master_test, :roles => :test do
  run_commands([
    'cd ~/cf-release',
    'git checkout master',
    './update'
  ])
end

desc 'Checkout a cf-release tag on the test machine.'
task :checkout_cf_release_tag_test, :roles => :test do
  run_commands([
    'cd ~/cf-release',
    'git checkout master',
    'git pull',
    "git branch -f #{tag}branch #{tag}",
    "git checkout #{tag}branch",
    'git submodule update --init --recursive'
  ])
end

desc 'Prepare the test VM and Micro Cloud for vcap-yeti tests.'
task :bvt_setup, :roles => :test do
  # Set the nameserver of the test machine to the Micro Cloud VM.
  resolv_conf_backup = '~/resolv.conf.backup'

  run "cp /etc/resolv.conf #{resolv_conf_backup}"
  run "echo 'nameserver #{micro_vm_ip}' > /tmp/resolv.conf"
  run "#{sudo} cp /tmp/resolv.conf /etc/resolv.conf"

  run_commands([
    '. ~/.bash_profile',
    "vmc --trace target http://api.#{domain}/",
    "vmc --trace register '#{admin_user}' --password '#{admin_password}' --verify '#{admin_password}'",
    "vmc --trace register #{normal_user} --password '#{normal_password}' --verify '#{normal_password}'",
    'cd ~/gem_cache_warmer',
    'vmc push -f warmer --runtime ruby19 || true',
    'vmc delete -f warmer || true',
    'vmc push -f warmer --runtime ruby18 || true',
    'vmc delete -f warmer || true'
    ])
end

desc 'Run vcap-yeti tests.'
task :bvt, :roles => :test do
  run_commands([
    '. ~/.bash_profile',
    "export VCAP_BVT_TARGET=#{domain}",
    "export VCAP_BVT_ADMIN_USER='#{admin_user}'",
    "export VCAP_BVT_ADMIN_USER_PASSWD='#{admin_password}'",
    "export VCAP_BVT_USER='#{normal_user}'",
    "export VCAP_BVT_USER_PASSWD='#{normal_password}'",
    ' cd ~/cf-release/src/tests',
    './update.sh',
    'rm -rf ~/.bvt',
    'bundle exec rake full[1]'
    ])
end

desc 'Revert temporary changes done to the test VM.'
task :bvt_teardown, :roles => :test do
  resolv_conf_backup = '~/resolv.conf.backup'
  run "#{sudo} cp #{resolv_conf_backup} /etc/resolv.conf"
end

desc 'Run vcap-java-client tests.'
task :vcap_java_client_tests, :roles => :test do
  run_commands([
    'cd ~/vcap-java-client',
    'git pull',
    'git submodule update --init --recursive',
    'cd vcap-java-client-test-apps',
    'mvn clean install',
    'cd ../cloudfoundry-client-lib',
    "mvn clean test -Pintegration-test -Dcloud.version=V1 -Dtest.app.memory=256 -Dvcap.target=http://api.#{domain} -Dvcap.email=#{normal_user} -Dvcap.passwd=#{normal_password}"
    ])
end

desc 'Distribute a Micro Cloud zip file.'
task :dist do
  zip_name = File.basename(zip_local_path)

  version_store = VersionStore.new('/var/lib/jenkins/versions.json')

  if is_release_version(zip_name)
    dist_release
    version_store.releases.insert(0, zip_name)
  else
    dist_nightly
    version_store.nightlies.insert(0, zip_name)
  end

  # Pass in default_version as a command line argument if you want to
  # set a default version that is not the latest release.
  if exists?(:default_version)
    version_store.default = default_version
  end

  version_store.write

  p "sending #{version_store.path} to CDN #{cdn_ftp_host}/micro/versions.json"
  p version_store.pretty
  Net::FTP.open(cdn_ftp_host, cdn_ftp_user, cdn_ftp_password) do |ftp|
    ftp.putbinaryfile(version_store.path, "micro/versions.json")
  end
end

desc 'Distribute a nightly version of the Micro Cloud.'
task :dist_nightly do
  p "sending #{zip_local_path} to CDN #{cdn_ftp_host}/micro/nightly"
  zip_name = File.basename(zip_local_path)

  Net::FTP.open(cdn_ftp_host, cdn_ftp_user, cdn_ftp_password) do |ftp|
    ftp.putbinaryfile(zip_local_path, "micro/nightly/#{zip_name}")
  end

  p "http://download3.vmware.com/cloudfoundry/micro/nightly/#{zip_name}"
end

desc 'Distribute a release version of the Micro Cloud.'
task :dist_release do
  p "sending #{zip_local_path} to CDN #{cdn_ftp_host}/micro/release"
  zip_name = File.basename(zip_local_path)

  Net::FTP.open(cdn_ftp_host, cdn_ftp_user, cdn_ftp_password) do |ftp|
    ftp.putbinaryfile(zip_local_path, "micro/release/#{zip_name}")
  end

  p "http://download3.vmware.com/cloudfoundry/micro/release/#{zip_name}"
end

desc 'Build and test the latest Micro Cloud Foundry.'
task :build, :roles => :build do
  clean

  set :tag, latest_cf_release_tag

  version_store = VersionStore.new('/var/lib/jenkins/versions.json')

  if version_store.has_release?(tag)
    checkout_cf_release_master
    checkout_cf_release_master_test
    release_desc = "#{tag}+"
    is_release_version = false
  else
    checkout_cf_release_tag
    checkout_cf_release_tag_test
    release_desc = tag
    is_release_version = true
  end

  create_release
  update_bosh_agent
  update_micro

  set :build_time, Time.now.strftime('%Y%m%d.%H%M%S')
  set :version, "#{release_desc}-#{build_time}"

  run_commands([
    '. ~/.bash_profile',
    "export BUILD_TIME=#{build_time}",
    "export MCF_VERSION=#{version}",
    'export UBUNTU_ISO=~/ubuntu-10.04.4-server-amd64.iso',
    'export UBUNTU_MIRROR=http://localhost:9999/ubuntu',
    'LATEST_RELEASE=`ls -t ~/cf-release/dev_releases/micro-*-dev.tgz | head -1`',
    'cd ~/bosh/agent',
    'rake stemcell2:mcf[vsphere,~/cf-release/micro/manifest.yml,$LATEST_RELEASE]'
    ])

  build_host = find_servers_for_task(current_task)[0]

  set :zip_local_path, "/tmp/micro-#{version}.zip"
  zip_name = File.basename(zip_local_path)

  zip_path = "mmb@#{build_host}:bosh/agent/mcf/#{build_time}/#{zip_name}"

  run_locally "scp #{zip_path} /tmp"

  puts run_locally "cd /tmp && unzip -o #{zip_name}"

  vmx = '/tmp/micro/micro.vmx'

  run_locally "#{vmrun} start #{vmx} nogui"

  sleep 30

  config_commands = <<-eos
quit
y
1
#{micro_password}
#{micro_password}
1
#{http_proxy}
#{domain}
#{admin_user}
eos

  vm_console_send vmx, config_commands, vm_initial_password

  # Give MCF time to boot.

  sleep 300

  # Turn on online mode.
  vm_console_send vmx, "\n6\n", micro_password

  set :micro_vm_ip, vm_ip(vmx, micro_password)

  p micro_vm_ip

  bvt_setup
  bvt
  vcap_java_client_tests
  bvt_teardown

  dist

  # Archive build?

  # Cleanup.

  run_locally "#{vmrun} stop #{vmx} nogui"
  run_locally 'rm -rf /tmp/micro'
end
